# Clean-Architecture-Book
Clean Architecture

第16章标题为《独立性》，探讨了系统架构中如何实现各部分的独立性，以支持系统的不同使用场景和开发模式。这个章节详细阐述了如何通过分离系统的不同层次和用例，最大化灵活性、开发效率以及系统的易部署性。

1. 用例（Use Cases）
系统架构首先必须支持系统的用例，也就是支持系统的预期行为。无论是购物车系统还是订单处理系统，系统的架构都需要清晰地展现其主要用例，使其在架构层次上显而易见。在这一点上，良好的架构并不仅仅依赖于功能，而是需要通过清晰的系统设计将功能呈现出来，使得开发者能够轻松找到系统的行为和对应的功能模块。

为了确保这一点，架构师应当关注如何将这些行为抽象化，确保架构清晰可见。理想的架构会将系统的主要功能模块，例如订单添加、订单删除等，划分为各自独立的部分，这些功能应该是系统的顶级元素，具有清晰的名称和明显的功能描述。

2. 操作（Operation）
除了支持系统行为，架构在系统运行中也起着重要作用。架构应当支持系统的性能需求，例如高吞吐量、低延迟等。具体实现方式可能包括将系统的处理元素拆分为多个小服务，这些服务可以在多个服务器上并行运行，从而提高系统的扩展性和运行效率。

良好的架构应当尽可能地开放操作选项。系统架构设计得越松散，越能适应未来的操作需求变化。比如，一个良好的架构能够从单一的进程扩展到多线程甚至微服务架构，而不需要对系统的基本结构进行大幅度调整。

3. 开发（Development）
在系统的开发过程中，架构的设计同样起着至关重要的作用。良好的架构应该能够支持团队的并行开发。为了避免团队之间的干扰，系统需要被合理地划分为多个独立的组件。这些组件可以分别分配给不同的团队进行开发，从而提高开发效率。

这里引用了康威定律（Conway’s Law）：任何组织设计的系统，其结构必然反映该组织的沟通结构。因此，一个多团队开发的系统架构必须适应这种团队的结构。通过对系统进行适当的分区，能够确保各个团队可以独立工作，减少沟通成本和协调的负担。

4. 部署（Deployment）
架构在系统的部署中也起着决定性的作用。理想的架构设计应当能够使系统在构建之后即可部署，不依赖于复杂的配置脚本或手动操作。这就需要架构设计能够将系统分割成多个可独立部署的部分，确保每个组件都能够单独启动和集成。

通过这种方法，系统的各个部分可以分别进行部署，甚至在运行时也能够替换或更新单个组件，而不影响系统的其他部分。这种设计大大提高了系统的灵活性和可维护性，能够适应持续交付和频繁更新的需求。

5. 保持选择的开放性（Leaving Options Open）
在应对系统复杂性的过程中，架构师需要平衡各方需求，并尽可能地保持架构的灵活性。问题在于，通常在项目初期，架构师并不完全清楚系统所有的用例、操作约束或团队结构。甚至这些因素在系统生命周期中也会不断变化。因此，架构设计必须尽可能为未来的变化留出空间。

解决这一问题的关键在于，架构师可以采用一些相对廉价的架构原则，帮助将系统划分为独立的组件，从而在尽量长的时间内保持尽可能多的选项开放。

6. 分离层（Decoupling Layers）
在设计系统架构时，架构师通常知道系统的基本目标是什么，但不一定知道所有的用例。因此，使用单一职责原则（SRP）和共同闭包原则（CCP），可以将那些由于不同原因而变化的部分分离出来，收集那些由于相同原因而变化的部分。具体来说，UI通常由于与业务规则无关的原因发生变化，因此应当将UI部分与业务规则部分分离开。

此外，架构师还可以使用垂直的切片方法，将系统按用例划分为多个竖向的薄片（thin slices），每个用例横跨不同的系统层次。通过这种方式，系统的UI、业务规则和数据库等部分可以分别演化，避免相互影响。

7. 独立开发性（Independent Develop-ability）
系统的各个组件应当能够独立开发，减少团队间的干扰。例如，UI团队和业务规则团队应当能够并行工作，而不互相影响。为了实现这一点，系统的用例也应当被解耦。添加订单和删除订单的用例应当独立存在，确保一个用例的修改不会影响另一个用例。

通过解耦层和用例，系统架构可以支持团队的组织结构，无论团队是按照功能、组件还是层级来划分，架构都能够提供足够的灵活性，支持不同的开发模式。

8. 独立可部署性（Independent Deployability）
通过解耦用例和层，系统在部署时也能具备高度的灵活性。如果解耦做得好，理论上可以实现对系统各个层次和用例的热插拔。也就是说，开发者可以通过添加一些新的JAR文件或服务，来增加一个新功能，而不需要重新部署整个系统。

这种独立可部署性极大地提高了系统的运维效率和可靠性，能够确保系统在运行时可以平稳地进行更新和维护。

9. 重复问题（Duplication）
许多架构师往往会因为对代码重复的恐惧而陷入困境。尽管代码重复通常是不好的，但书中指出，必须区分不同类型的重复：真实的重复和偶然的重复。如果两个表面上相似的代码片段在不同时间、由于不同原因发生变化，那么它们实际上并不是重复的。

对于看似重复的部分，架构师需要谨慎处理，确保不要过早地将它们统一起来。否则，随着系统的演进，可能会发现这些部分逐渐分化，最终很难再次将它们分离出来。

10. 解耦模式（Decoupling Modes）
系统的解耦可以发生在多个层次上：源代码层、二进制部署层和服务层。尽管服务层的解耦具有高度的灵活性，但其开发和维护成本也较高。因此，作者建议在可能的情况下，先将组件在源代码层上解耦，只有在需要时才将其提升为独立的服务。

这种分阶段的解耦方式，可以使系统在初期保持单体架构的简单性，但在需要时也可以逐渐扩展为服务架构或微服务架构。随着系统的演变，解耦模式也可能随之改变。良好的架构应当允许系统从单体架构逐步扩展为一组独立部署的单元，甚至进一步发展为完全解耦的微服务架构。



第17章《边界：划定界限》探讨了软件架构中的边界问题，即如何在系统中划分和管理不同组件之间的边界。良好的边界划分是构建可维护、灵活且可扩展的软件系统的基础。通过合理划定边界，开发者可以将系统的核心业务逻辑与外部细节（如数据库、UI等）隔离开来，延迟技术决策，并减轻系统演进过程中耦合和复杂性的增加。以下是对第17章的详细总结：

1. 软件架构的核心：划定边界
软件架构的艺术在于划定边界，这些边界将系统的不同部分隔离开来，并限制这些部分之间的相互了解。划定边界有助于使系统的不同组件在不同的开发周期中相互独立运行，减少相互之间的依赖，确保系统的核心业务逻辑不受外部细节的干扰。这一章指出，边界的划定应尽早进行，有时甚至在代码编写之前就已经开始，以便推迟那些不必要的技术决策，并使这些决策不会污染核心业务逻辑。

2. 避免早期决策
架构师的目标是通过合理设计最小化构建和维护系统所需的人力资源。导致系统复杂度增加的主要因素之一是耦合，特别是与早期决策的耦合。过早决定使用某种技术、框架或库，可能会导致后期维护和扩展上的困难。

早期的架构设计应尽可能推迟与具体实现有关的决策，例如关于数据库、Web服务器、依赖注入框架等。这些决策与系统的业务需求无关，因此应尽量推迟。在理想的系统架构中，这些决定应该是可选的、可推迟的，而且推迟这些决定不应对系统的核心业务逻辑产生重大影响。

3. 现实中的案例
本章通过几个失败的架构案例，强调了不合理边界划定的危险性。举例来说，一家公司为了跟上互联网的浪潮，决定将其原本成功的桌面应用程序转换为Web应用程序。该公司为此采用了三层架构，并过早决定在各层之间采用大量的对象序列化和通信机制。然而，最终这个系统只在单一服务器上运行，而不需要分布式的服务器场，导致他们为那些永远不会出现的需求付出了大量开发成本。

这类案例显示出，过早做出关于技术实现的决策会对项目造成严重影响。公司不仅没有实现其预期的架构目标，反而增加了开发和维护的复杂性与成本。

4. FitNesse案例：一个成功的边界划分
与失败的架构相比，书中还介绍了FitNesse项目的成功案例。FitNesse是一个用于编写验收测试的Wiki工具，最初开发时并未选择任何现成的Web服务器或框架，而是自己构建了一个简易的Web服务器。这个决策帮助开发者推迟了与Web服务器和框架相关的技术选择，直到他们确定了确实需要这类功能为止。这一决策显著减少了开发中的复杂性，使得团队能够专注于核心业务功能的开发。

通过划定边界，FitNesse的业务逻辑与底层技术实现之间建立了一道防火墙，这使得后期技术选择变得更加灵活和高效。

5. 划定边界的时机与方法
开发者应在不同模块之间划定边界，尤其是业务逻辑与用户界面、数据库之间的边界。用户界面通常会频繁变化，且与业务规则的变化无关，因此应与业务逻辑分离。同样，数据库的实现细节不应渗透到业务规则中。数据库只是用于存储和获取数据的工具，业务规则不需要了解数据库的结构或查询语言，而只需要知道可以通过某些方法存储或检索数据。这意味着数据库应当通过接口与业务逻辑进行交互。

这种边界划分使得业务逻辑能够独立于具体的数据库实现。例如，系统可以在不修改业务逻辑的情况下切换不同的数据库（如MySQL、CouchDB或文件系统），因为数据库的实现已经被封装在接口后面。

6. 插件式架构
书中提倡插件式架构，即将那些并非系统核心的功能模块设计为插件。这种设计使得系统的核心业务逻辑独立于外部模块，如用户界面、数据库等。在这种架构下，用户界面或数据库都可以作为插件接入系统，从而实现高灵活性和可扩展性。例如，系统可以在需要时切换不同的用户界面技术或数据库，而无需对核心业务逻辑进行重大修改。

插件式架构的好处还在于，系统不同部分的开发者可以独立工作，减少了耦合对开发进度的影响。系统中的变化不会轻易传播到其他无关部分，从而避免了系统脆弱性。

7. SRP和边界划分
本章进一步强调了**单一职责原则（SRP）**在划定边界时的重要性。SRP告诉我们应该在哪些地方划定边界，即系统中那些因不同原因或在不同时间变化的部分，应当通过边界分隔开来。具体而言，GUI层和业务规则层变化的原因和频率不同，因此应当划定边界。同样，依赖注入框架和业务规则层的变化原因也不同，因此也应当划定边界。

8. 插件架构的实际应用
为了更好地说明插件架构的优越性，书中以ReSharper与Visual Studio的关系为例。ReSharper是一款插件，它依赖于Visual Studio，但Visual Studio并不依赖ReSharper。这种单向依赖关系确保了Visual Studio的开发团队不会因为ReSharper的变化而受到干扰，但ReSharper的开发团队必须跟随Visual Studio的变化进行调整。这种依赖关系的非对称性是插件架构的核心理念，即通过控制依赖方向，减少系统中的耦合和变化的传播。

9. 边界的意义
本章最后总结道，软件架构中的边界划分至关重要。通过合理划定边界，系统可以实现模块化，减少耦合，提高灵活性和可维护性。架构师的任务是在系统中识别变化的轴，并根据这些变化的原因和频率划定边界。插件式架构是一种有效的边界划分方式，通过将可变的部分封装为插件，核心业务逻辑可以保持稳定，系统可以随着需求的变化轻松进行扩展和调整。



第18章《边界解剖》深入探讨了软件架构中的边界划分，以及在不同场景下如何跨越边界来确保系统的模块化和解耦性。主要内容涵盖了边界的多种形式及其应用，重点介绍了边界跨越、单体结构、部署组件、线程、本地进程和服务，以及这些边界形式在不同系统设计中的重要性和使用场景。以下是对该章内容的详细总结：

1. 边界的定义与跨越
边界的作用是将系统划分为多个部分，减少它们之间的耦合。在运行时，边界的跨越体现为一个函数调用另一个函数，并传递相应的数据。核心挑战在于如何管理源代码的依赖关系，确保系统的修改不会影响其他不相关的模块。

跨越边界时，通常会涉及到源代码依赖。如果一个源代码模块发生了变化，其他依赖于它的模块也可能需要重新编译、重新部署。通过边界管理，可以有效地建立“防火墙”，隔离变化，减少连锁反应对系统的影响。

2. 单体架构的挑战
单体架构是最常见的系统架构之一，通常表现为一个大规模的单一部署单元，比如一个包含所有功能的可执行文件。单体系统的部署尽管在物理上是单一的，但其内部可以通过严格的功能分离实现逻辑上的模块化。边界跨越在这种系统中通常只是简单的函数调用，虽然速度快，但系统各部分的开发、测试和部署会相对复杂，多个团队的工作容易相互影响。

尽管单体结构内部的通信效率很高，通常只是函数调用，但这种架构容易产生耦合，导致系统的扩展性较差。

3. 部署组件
一个更物理化的边界表现是部署组件。部署组件如Java中的JAR文件或.NET中的DLL文件，这些组件通常以二进制形式进行部署，不需要重新编译代码。这类组件的通信通常也只涉及函数调用，通信成本较低，边界跨越很快，除非涉及动态链接或运行时加载。

这种结构下的开发模式与单体结构类似，但组件间的依赖管理更为严格。每个组件可以被独立开发、测试和部署，从而实现更高的灵活性。

4. 线程
线程不是架构边界，而是用于组织系统执行顺序的机制。在单体架构或部署组件中，线程可以完全包含在组件内部，或者跨越多个组件进行执行。线程的作用是提高系统的并发性和性能，而不是分离组件。因此，线程在某种程度上不会影响系统的解耦性，但可以影响系统的执行顺序和效率。

5. 本地进程
本地进程提供了更强的物理边界。本地进程运行在独立的地址空间内，通常通过操作系统调用、套接字、消息队列等方式进行通信。这种隔离程度比单体架构和部署组件更强，进程之间的内存不共享，通信成本也更高，因为涉及数据的编组、解组和上下文切换。

尽管通信成本较高，本地进程之间的强隔离使得系统更具稳健性和安全性。进程间的相互影响更少，每个进程可以独立开发、部署和运行。

6. 服务
服务代表了最强的边界形式。服务是独立的进程，它们可能运行在同一个物理处理器上，也可能运行在不同的网络节点上。服务间的通信通常通过网络进行，因此通信延迟高且成本大，需要避免频繁的交互（即“话唠”式通信）。服务间的解耦性非常高，能够有效支持大规模的分布式系统。

通过服务划分的系统具有高度的独立性和灵活性，但需要面对高通信成本和网络延迟的挑战。

7. 边界的选择与设计
在设计边界时，架构师需要根据系统的复杂性、团队结构、部署要求等因素来决定如何划分边界。过多的边界会增加系统的复杂性和管理成本，而过少的边界则可能导致系统的耦合度过高。理想的设计是在合适的地方设置合理的边界，以达到系统性能、可扩展性和可维护性的平衡。

本章通过对比单体结构、部署组件、线程、本地进程和服务的边界形式，展示了如何根据系统需求和约束条件选择合适的边界类型。通过合理划分边界，系统可以在保持高性能的同时，实现模块化、解耦和独立部署。



第22章：《整洁架构》（The Clean Architecture）
<img width="583" alt="image" src="https://github.com/user-attachments/assets/b1fda2f1-4cb6-4ad2-adea-1aa7421c1a00">


1. 整洁架构的核心理念
整洁架构融合了以下几种架构模式的思想：

六边形架构（Hexagonal Architecture/Ports and Adapters）
数据、上下文与交互（DCI）
边界控制实体（BCE）​
这些架构模式在细节上有所不同，但它们都遵循一个核心目标：关注点分离（Separation of Concerns）。这种分离通过将软件划分为多个层次来实现，每个层次处理不同的责任，比如业务规则层和用户界面层。

整洁架构的特点：

独立于框架：架构不依赖于任何特定的框架，使框架成为工具而非限制。
可测试性：业务规则可以在没有UI、数据库或其他外部依赖的情况下进行测试。
独立于UI：UI可以轻松更改而不影响业务规则。
独立于数据库：数据库可以随意更换，而不会对业务规则产生影响。
独立于外部代理：业务规则与外部世界的接口无关​​。
2. 依赖规则（The Dependency Rule）
依赖规则是整洁架构的核心原则之一：

规则：源代码的依赖关系必须仅指向内层，即高层次的政策和规则。
含义：内圈的代码（如业务规则）不能引用外圈的任何东西，包括类、函数或变量。具体而言，外圈的数据格式不应影响内圈​​。
层次结构
整洁架构使用同心圆的形式来表示不同的架构层次：

实体层（Entities）：封装企业级的核心业务规则，几乎不受外部系统的影响。
用例层（Use Cases）：实现应用特定的业务规则，协调实体的行为以完成用例目标。
接口适配器层（Interface Adapters）：负责将数据从用例和实体的格式转换为外部系统（如UI或数据库）所需的格式。
框架和驱动层（Frameworks and Drivers）：包含各种框架和工具，是系统与外部世界交互的入口​​。


典型场景（A Typical Scenario）
<img width="620" alt="image" src="https://github.com/user-attachments/assets/9c717ca3-f9f1-41ae-91b9-d1bd6907e283">

作者通过一个基于Web的Java系统示例，展示了整洁架构的实际应用：

流程：
用户输入通过Web服务器传递给控制器（Controller）。
控制器将数据打包为简单的Java对象，传递给用例交互器（UseCaseInteractor）。
用例交互器使用这些数据操作实体，并通过数据访问接口（DataAccessInterface）与数据库交互。
最终的输出数据通过输出边界接口（OutputBoundary）传递给表示器（Presenter）。
表示器将输出数据转换为视图模型（ViewModel），供视图（View）渲染​。
关键点：

所有依赖关系都遵循依赖规则，从外圈指向内圈。
数据在边界之间传递时应使用简单的数据结构，以避免违反依赖规则​。
4. 整洁架构的优势
整洁架构通过严格的依赖管理和层次分离，实现以下目标：

灵活性：系统能够轻松适应变化，比如替换UI框架或迁移数据库。
可维护性：每一层的职责明确，修改某一层不会对其他层产生不良影响。
测试性：业务逻辑与外部依赖隔离，可以单独测试​​。


### 第23章：Presenters与Humble Objects

#### **Humble Object模式**
Humble Object模式是一种设计模式，其核心思想是通过将难以测试的行为与易于测试的行为分离到两个模块或类中，简化单元测试。一个模块“谦卑”，只包含最基本的难以测试的行为；另一个模块则包含移除这些谦卑行为后的可测试部分。

#### **Presenters与Views**
- **View** 是一个典型的谦卑对象，主要任务是将数据从 ViewModel 显示到界面上，且不对数据进行任何处理。
- **Presenter** 是可测试对象，负责接收来自应用的数据并将其格式化，以便 View 能简单地加载到界面上。Presenter 的主要职责是：
  - 将应用传递的复杂对象（如日期、货币）格式化为字符串或布尔值。
  - 管理界面元素的状态（如按钮名称、是否可用）并将这些信息存储到 ViewModel 中。

#### **测试与架构**
Humble Object模式通过将行为分离到可测试和不可测试的部分来增强架构的可测试性。这种分离通常定义了架构边界，例如Presenter和View之间的边界。

#### **数据库网关**
- 数据库网关是位于用例交互器和数据库之间的多态接口。
- 它们负责定义所有可能的数据库操作（如创建、读取、更新、删除）。
- 网关的实现通常位于数据库层，且这些实现属于谦卑对象，因为它们只负责执行SQL查询。

#### **数据映射器**
- ORMs（如Hibernate）实际上是“数据映射器”，它们将关系数据库表中的数据加载到数据结构中。
- 数据映射器属于谦卑对象，应当位于数据库层，形成网关接口和数据库之间的边界。

#### **服务监听器**
- 服务边界（Service Boundary）也是Humble Object模式的一部分。
- 数据被加载到简单的数据结构中，通过边界传递到外部服务模块；反之亦然，从服务接口接收的数据被格式化后传递到应用。


### 第24章：部分边界

#### **背景与动机**
完整的架构边界需要对称的多态接口（Boundary Interfaces）、输入和输出数据结构、以及管理两个组件独立编译和部署的依赖关系。这种隔离虽然有助于架构清晰，但代价高昂。在某些情况下，架构师可能会认为完全实现边界的成本过高，因此选择实施“部分边界”作为妥协。

#### **部分边界的实现方式**
1. **跳过最后一步（Skip the Last Step）**：
   - 执行独立编译和部署组件所需的所有设计工作，但将这些组件编译为一个整体。
   - 这种方法减少了版本控制和发布管理的复杂性，但仍然需要完成大部分初始设计工作。
   - **示例**：FitNesse 的设计原本允许将其 Web 服务器组件与 Wiki 和测试功能分离，但为了简化用户体验，将它们打包为一个组件。随着时间推移，组件间的分离逐渐弱化。

2. **一维边界（One-Dimensional Boundaries）**：
   - 利用经典的策略模式（Strategy Pattern），通过接口（如 `ServiceBoundary`）实现客户端与服务实现类之间的隔离。
   - 这种方法提供了未来扩展为完整边界的基础，但如果缺乏对称接口，分离可能会因开发者不当行为而退化。

3. **外观模式（Facade Pattern）**：
   - 定义一个外观类（Facade）作为简单的接口，将客户端与底层服务分离。
   - 这种方法牺牲了依赖反转原则（Dependency Inversion Principle），因为客户端仍然间接依赖所有服务类，且代码变更会导致连锁反应。

#### **部分边界的优势与挑战**
- **优势**：
  - 减少管理多个独立组件的复杂性。
  - 为未来扩展到完整边界提供了结构基础。
- **挑战**：
  - 部分边界的维护需要开发团队的纪律性。
  - 如果未来并未发展成完整边界，部分边界可能会导致架构退化。


### 第25章总结：层与边界


#### **1. 简单系统中的传统三层架构**
- **传统划分**：简单系统通常被分为三层：
  - 用户界面（UI）
  - 业务规则（Business Rules）
  - 数据库（Database）
- **问题**：虽然这种分层对于简单系统足够，但在复杂系统中会显得不足，可能导致难以扩展或维护。


#### **2. 示例：游戏“猎杀温普斯”（Hunt the Wumpus）**
该游戏用于演示复杂系统中的架构设计：
1. **分离 UI 和规则**：
   - 游戏规则与 UI 解耦，通过语言无关的 API 连接。
   - 允许 UI 使用不同的语言或展现形式。
2. **存储与规则分离**：
   - 游戏状态存储在持久化数据中，但游戏规则不依赖于具体存储实现。
   - 通过 API 隔离存储和游戏规则。
3. **依赖规则**：
   - 遵循依赖规则：依赖的方向始终从低级别细节指向高级别抽象。


#### **3. 数据流与依赖管理**
- **数据流方向**：
  - 用户输入通过 UI 层流向游戏规则层，规则处理后返回数据给 UI 显示。
  - 游戏规则与存储层间数据流独立，使规则可以在不修改存储的情况下变更。
- **分流**：
  - 将数据流分为多个独立流，例如用户交互流和数据持久化流，各自独立但统一在规则层处理。
  - 数据流越复杂，分流数可能增加，如在多人游戏中增加网络流。


#### **4. 高低层规则的划分**
- **低层规则**：
  - 处理具体细节，如地图连接和玩家移动。
- **高层规则**：
  - 处理抽象政策，如玩家健康状态和事件影响。
  - 高层规则可以利用低层规则的结果并进一步抽象决策，例如判定玩家胜负。


#### **5. 微服务与架构边界**
- **边界实现**：
  - 将高层规则与低层规则通过微服务 API 分隔，例如本地的移动管理和远程服务器的玩家管理。
  - 边界的实现有助于更好的独立部署和扩展。


#### **6. 关键思考：边界的成本与时机**
- **边界的成本**：
  - 完整实现边界需要显著的设计与维护成本。
  - 未能提前设计边界可能在后期增加昂贵的改造成本。
- **架构师的决策**：
  - 在避免过度设计的同时，架构师需预测未来可能需要的边界，权衡当前的边界设计需求。


### 第26章总结：主组件

#### **1. 主组件的作用**
- 每个系统至少有一个主组件，负责创建、协调和管理其他组件。这个组件被称为“Main”。
- 主组件是系统的主要入口点，代表最低级别的策略和最具体的细节。它的职责包括：
  - 创建工厂（Factories）、策略（Strategies）和其他全局设施。
  - 将控制权移交给系统的高级抽象部分。


#### **2. 依赖注入的实现**
- 在主组件中，应使用依赖注入框架注入所有依赖项。
- 一旦注入完成，主组件应通过常规方法分发这些依赖，而不是继续依赖框架。


#### **3. 主组件的“脏”特性**
- 主组件被认为是最“脏”的组件，因为它包含了许多具体细节。
- 示例中，主组件加载了游戏中所有的字符串信息（例如环境、形状、类型和装饰等），从而避免主逻辑代码直接处理这些具体细节。


#### **4. 示例：猎杀温普斯游戏中的主组件**
- **实现方式**：
  - 主函数中通过工厂创建游戏实例并初始化地图。
  - 包含用户输入的主循环，将解析后的命令交给更高级的组件处理。
- **职责分离**：
  - 主组件专注于创建和配置，实际处理逻辑由高层组件完成。
  - 例如，命令的具体执行由专用的命令类负责，而主组件只是将用户输入解析为对应命令。


#### **5. 主组件的扩展性与灵活性**
- 为了降低主组件的耦合，推荐将主组件与更“脏”的类（如`HuntTheWumpusFacade`）分离。通过这种方式，即使更改这些类，也不会导致主组件需要重新编译或部署。


#### **6. 主组件的核心设计原则**
- **职责单一**：主组件专注于初始化和协调任务。
- **解耦**：主组件负责加载其他类，但具体逻辑独立于主组件运行。
- **最低级别的依赖**：主组件应该尽量减少对系统其他部分的影响，从而保持灵活性。


### 第27章总结：服务架构的优缺点与实践（Services: Great and Small）

#### **1. 服务架构的流行与误区**
- **流行原因**：
  - 服务看似高度解耦，独立开发和部署。
  - 被认为是可扩展的架构解决方案。
- **误区**：
  - **解耦的错觉**：尽管服务可能在进程层面解耦，但它们经常通过共享数据耦合。例如，如果数据记录的结构改变，所有依赖这些记录的服务都需要更新。
  - **独立开发和部署的错觉**：由于共享数据或行为的复杂性，服务之间的协调往往是不可避免的。

#### **2. 实例分析：Kitty问题**
- **背景**：
  - 假设一个出租车聚合系统要增加送猫服务，涉及到多个约束（如司机或乘客对猫过敏）。
  - 为支持该功能，系统的多个服务（如用户界面、车辆选择、调度服务）都需要修改。
- **问题**：
  - 功能性分解的服务设计容易被跨服务的需求破坏。
  - 这表明服务间高度耦合，无法真正独立开发和部署。

#### **3. 面向对象的解决方案**
- 通过面向对象设计的原则（如SOLID原则），将变化隔离到独立的组件中。
- **关键方法**：
  - 使用基类和多态实现抽象分离。
  - 使用模板方法或策略模式将特定逻辑分离到可扩展的子组件中。
  - 添加新功能（如Kitty组件）无需修改现有组件，只需动态加载相关库。

#### **4. 基于组件的服务**
- 服务可以设计为组件化架构，将功能分为独立模块。
- 新功能通过扩展抽象类以组件的形式引入，无需重新部署整个服务。
- 这种设计符合开放-封闭原则（Open-Closed Principle），使服务更具扩展性和维护性。


#### **5. 横切关注点**
- 服务的架构边界不在服务之间，而是穿过服务，将其内部划分为组件。
- 通过依赖反转和组件化设计，解决横切关注点带来的复杂性。


### 第28章 测试边界（The Test Boundary）

第28章探讨了测试在系统中的地位，以及如何通过设计测试边界提高系统的测试性和维护性。

#### **1. 测试是系统的一部分**
- **测试作为系统组件**：
  - 测试被视为系统的一部分，与系统的其他部分一样参与架构设计。
  - 无论是单元测试、集成测试还是验收测试，从架构的角度看，它们都是等价的。
  - 测试遵循依赖规则（Dependency Rule），始终依赖于被测试的系统内部组件，而系统不依赖于测试。

- **测试的独立性**：
  - 测试通常部署在测试系统中，与生产系统分离。
  - 测试是最隔离的系统组件，不直接影响系统的运行，其作用仅在于支持开发。


#### **2. 设计以支持测试性**
- **测试耦合问题**：
  - 测试可能与系统强耦合，导致系统中轻微的变化引发大量测试失败，这被称为“脆弱测试问题”（Fragile Tests Problem）。
  - 比如，如果测试通过 GUI 验证业务规则，则任何登录页面或导航结构的变化都可能导致大量测试失败。

- **解决方法**：
  - 设计时避免依赖容易变化的部分（如 GUI）。
  - 通过特定的 API 测试业务规则，从而使测试与 GUI 解耦。



#### **3. 测试 API 的作用**
- **测试 API 的设计**：
  - 构建一个专用的测试 API，用于测试业务规则和系统行为。
  - 测试 API 的功能超越用户接口的范围，允许绕过安全约束、避免高成本资源（如数据库），以及将系统置于可测试状态。

- **减少结构性耦合**：
  - 测试 API 还可以减少测试与应用程序的结构性耦合。例如，避免每个生产类对应一个测试类的设计。



#### **4. 测试边界的意义**
- 测试边界明确了系统与测试之间的关系，保证测试的独立性和系统的可维护性。
- 测试在设计时需要被视为核心的一部分，而非后期附加的工具，这样可以避免测试成为系统变化的阻力。



### 第29章总结：清洁嵌入式架构（Clean Embedded Architecture）

第29章讨论了如何在嵌入式系统中应用清洁架构原则，以提高代码的可测试性、灵活性和可维护性，同时降低对硬件的依赖。

---

#### **1. 嵌入式系统的挑战**
- **目标硬件瓶颈**：
  - 嵌入式开发常因依赖目标硬件测试而受阻。硬件开发与软件并行进行，硬件缺陷可能拖慢进度。
  - 若代码未遵循清洁架构原则，所有测试都需在目标硬件上进行，导致效率低下。

- **固件的局限性**：
  - 嵌入式代码通常掺杂了硬件相关的实现细节（如直接访问寄存器），这将其转变为“固件”，使代码难以适应硬件升级。

---

#### **2. 清洁嵌入式架构的原则**
1. **硬件抽象层（HAL, Hardware Abstraction Layer）**：
   - **定义**：将硬件细节封装在 HAL 中，使软件只与抽象接口交互。
   - **作用**：
     - 隔离硬件变化，如更换处理器或外设。
     - 提高代码的可测试性，使应用逻辑无需依赖实际硬件。

2. **操作系统抽象层（OSAL, Operating System Abstraction Layer）**：
   - **必要性**：直接依赖 RTOS 或内核可能引入大量变化风险，例如更换操作系统或其 API。
   - **解决方法**：
     - 通过 OSAL 将操作系统视为实现细节，提供统一接口。
     - 使系统易于迁移，并可在脱离操作系统的环境下测试。

3. **编程接口和可替换性**：
   - 鼓励通过接口编程以实现组件替换。
   - 限制接口定义的范围，仅包含必要的函数声明，避免实现细节外泄。

---

#### **3. 应用清洁架构的益处**
- **可测试性**：
  - HAL 和 OSAL 提供测试切入点，允许在非目标硬件或非操作系统环境下测试应用逻辑。
  - 避免通过硬件寄存器直接测试的需求。

- **减少代码重复**：
  - 通过抽象层，减少嵌入式代码中常见的条件编译指令（如 `#ifdef`），从而简化代码管理。

- **代码的长久适用性**：
  - 软件代码被隔离于硬件和操作系统，使其寿命不受限于底层硬件的生命周期。



#### **4. 总结与建议**
- 嵌入式开发需将硬件和操作系统视为实现细节，采用清洁架构提高代码的独立性和灵活性。
- 开发人员应尽量减少固件的比例，通过抽象层实现功能分离，使代码更易于扩展和维护。
- 清洁嵌入式架构的核心在于提升可测试性和适应性，为代码赋予更长的生命力。
